/*
 -----------------------------------------------------------------------------
 Filename:    OgreBullet_Collision_test.cpp
 -----------------------------------------------------------------------------
 
 This source file is generated by the Ogre AppWizard.
 
 Check out: http://conglomerate.berlios.de/wiki/doku.php?id=ogrewizards
 
 Based on the Example Framework for OGRE
 (Object-oriented Graphics Rendering Engine)
 
 Copyright (c) 2000-2007 The OGRE Team
 For the latest info, see http://www.ogre3d.org/
 
 You may use this sample code for anything you like, it is not covered by the
 LGPL like the rest of the OGRE engine.
 -----------------------------------------------------------------------------
 */
 
 #include "OBTutorial2.h"
#include "MyMotionState.h"
btVector3 toBulletVector(Ogre::Vector3 oVec)
{
    btVector3 bVec = btVector3(btScalar(oVec.x), btScalar(oVec.y), btScalar(oVec.z));
    return bVec;
    
}
//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
OBTutorial2::OBTutorial2(void)
{      
    mCollisionConfiguration = new btDefaultCollisionConfiguration();
    mDispatcher = new btCollisionDispatcher(mCollisionConfiguration);
    mBroadphase = new btDbvtBroadphase();
   
    mSolver = new btSequentialImpulseConstraintSolver();
}
//-------------------------------------------------------------------------------------
OBTutorial2::~OBTutorial2(void)
{
    delete mDispatcher;
    delete mSolver;
    delete mBroadphase;
    delete mCollisionConfiguration;
    delete mWorld;
}

void OBTutorial2::createBoxShape(Ogre::Entity* entity, Ogre::Vector3 position, bool bStatic)
{

   Ogre::SceneNode *node = entity->getParentSceneNode();
   Vector3 size = node->_getDerivedScale()*entity->getBoundingBox().getHalfSize();
   float mass =  bStatic ? 0.0f : 1.0f;
   srand( (unsigned)time( NULL ) );

   node->setPosition(position);
   node->setOrientation(Quaternion(Degree(Ogre::Math::RangeRandom(0.0,60.0)), Vector3::UNIT_Y));

   btBoxShape *sceneBoxShape = new btBoxShape(toBulletVector(size)); // konvertovat vektor size

   // and the Bullet rigid body
   MyMotionState * defaultMotionState = new MyMotionState(btTransform(btQuaternion(btScalar(0),btScalar(0),btScalar(0),btScalar(1))), node);
   btRigidBody *defaultBody = new btRigidBody(btScalar(1), defaultMotionState, sceneBoxShape);
  /* defaultBody->setShape(node, 
						sceneBoxShape, 
						0.6f,                             // dynamic body restitution
		                0.6f,                             // dynamic body friction
		                mass,                             // dynamic bodymass
		                node->_getDerivedPosition(),      // starting position of the box
		                node->_getDerivedOrientation());  // orientation of the box**/
	mShapes.push_back(sceneBoxShape);
	mBodies.push_back(defaultBody);
	mNumEntitiesInstanced++;				
}


//-------------------------------------------------------------------------------------
bool OBTutorial2::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
    bool ret = BaseApplication::frameRenderingQueued(evt);
    if(!processUnbufferedInput(evt)) return false;
    return ret;
}

//-------------------------------------------------------------------------------------
bool OBTutorial2::frameStarted(const FrameEvent& evt)
{
	bool ret = BaseApplication::frameStarted(evt);
        std::cerr << "sem tady" << std::endl;
 	mWorld->stepSimulation(evt.timeSinceLastFrame);	// update Bullet Physics animation
        std::cerr << "sem tady" << std::endl;
	return ret;
}
 
//-------------------------------------------------------------------------------------
bool OBTutorial2::frameEnded(const FrameEvent& evt)
{
	bool ret = BaseApplication::frameEnded(evt);
	mWorld->stepSimulation(evt.timeSinceLastFrame);	// update Bullet Physics animation
	return ret;
}

//-------------------------------------------------------------------------------------
void OBTutorial2::createScene(void)
{

    mCamera->setPosition(Vector3(0,18,70));
    mCamera->lookAt(Vector3(0,0,-300));
    mCamera->setNearClipDistance(5);

    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.9, 0.9, 0.9));


    // Start Bullet
    mWorld = new btDiscreteDynamicsWorld(mDispatcher,  // gravity vector for Bullet
                                mBroadphase, mSolver, mCollisionConfiguration );
 
    // add Debug info display tool
 	//debugDrawer = new OgreBulletCollisions::DebugDrawer();
 	//debugDrawer->setDrawWireframe(true);	// we want to see the Bullet containers
 
 	//mWorld->setDebugDrawer(debugDrawer);
 	//mWorld->setShowDebugShapes(true);		// enable it if you want to see the Bullet containers
 	//SceneNode *node = mSceneMgr->getRootSceneNode()->createChildSceneNode("debugDrawer", Ogre::Vector3::ZERO);
 	//node->attachObject(static_cast <SimpleRenderable *> (debugDrawer));
 
    // Define a floor plane mesh
 	Entity *ent;
    Plane p;
    p.normal = Vector3(0,1,0); p.d = 0;
    MeshManager::getSingleton().createPlane("FloorPlane", 
                          ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
                          p, 200000, 200000, 20, 20, true, 1, 9000, 9000, 
                          Vector3::UNIT_Z);
    // Create an entity (the floor)
    ent = mSceneMgr->createEntity("floor", "FloorPlane");
 	ent->setMaterialName("Examples/BumpyMetal");
    mSceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(ent);
 
 	// add collision detection to it
 	btCollisionShape *Shape;
 	Shape = new btStaticPlaneShape(toBulletVector(Ogre::Vector3(0,1,0)), 0); // (normal vector, distance)
 	// a body is needed for the shape
        MyMotionState * defaultMotionState = new MyMotionState(btTransform(btQuaternion(btScalar(0),btScalar(0),btScalar(0),btScalar(1))), ent->getParentSceneNode());
        btRigidBody *defaultBody = new btRigidBody(btScalar(1), defaultMotionState, Shape);
 	btRigidBody *defaultPlaneBody = new btRigidBody(btScalar(0), defaultMotionState, Shape);
 	//defaultPlaneBody->setStaticShape(Shape, 0.1, 0.8);// (shape, restitution, friction)
 	// push the created objects to the deques
 	mShapes.push_back(Shape);
 	mBodies.push_back(defaultPlaneBody);


 	// create an cube mesh
 	Entity *entity = mSceneMgr->createEntity(
 					"Box" + StringConverter::toString(mNumEntitiesInstanced),
 					"cube.mesh");			    
 	entity->setMaterialName("Examples/BumpyMetal");
       Ogre::SceneNode *node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
 	node->attachObject(entity);
 	node->scale(0.05f, 0.05f, 0.05f);	// the cube is too big for us
	createBoxShape(entity, Ogre::Vector3(0.0,0.0,0.0), false);


}
//-------------------------------------------------------------------------------------
bool OBTutorial2::processUnbufferedInput(const Ogre::FrameEvent& evt)
{
    static float mToggle = 0;

    if (mToggle>0)
        mToggle -= evt.timeSinceLastFrame;

	// create and throw a box if 'B' is pressed
	if(mKeyboard->isKeyDown(OIS::KC_B) && mToggle <=0)
	{
		Vector3 size = Vector3::ZERO;	// size of the box
		// starting position of the box
		Vector3 position = (mCamera->getDerivedPosition() + mCamera->getDerivedDirection().normalisedCopy() * 10);
 
		// create an ordinary, Ogre mesh with texture
	    Entity *entity = mSceneMgr->createEntity(
 					"Box" + StringConverter::toString(mNumEntitiesInstanced),
 					"cube.mesh");			    
		entity->setCastShadows(true);
                createBoxShape(entity, position, false);
		// we need the bounding box of the box to be able to set the size of the Bullet-box
		AxisAlignedBox boundingB = entity->getBoundingBox();
		size = boundingB.getSize(); size /= 2.0f; // only the half needed
		size *= 1.00f;	// Bullet margin is a bit bigger so we need a smaller size
 									// (Bullet 2.76 Physics SDK Manual page 18)
		entity->setMaterialName("Examples/BumpyMetal");
		SceneNode *node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
		node->attachObject(entity);
		node->scale(0.05f, 0.05f, 0.05f);	// the cube is too big for us
		size *= 0.05f;						// don't forget to scale down the Bullet-box too
 
		// after that create the Bullet shape with the calculated size
		/*OgreBulletCollisions::BoxCollisionShape *sceneBoxShape = new OgreBulletCollisions::BoxCollisionShape(size);
		// and the Bullet rigid body
		OgreBulletDynamics::RigidBody *defaultBody = new OgreBulletDynamics::RigidBody(
 					"defaultBoxRigid" + StringConverter::toString(mNumEntitiesInstanced), 
 					mWorld);
		defaultBody->setShape(	node,
 						sceneBoxShape,
 						0.6f,			// dynamic body restitution
 						0.6f,			// dynamic body friction
 						1.0f, 			// dynamic bodymass
 						position,		// starting position of the box
 						Quaternion(0,0,0,1));// orientation of the box
        mNumEntitiesInstanced++;				
 
		defaultBody->setLinearVelocity(
					mCamera->getDerivedDirection().normalisedCopy() * Ogre::Math::RangeRandom(0.7f,20.0f) ); // shooting speed
		// push the created objects to the dequese
		mShapes.push_back(sceneBoxShape);
		mBodies.push_back(defaultBody);		**/		
		mToggle = 0.5;
	}


    return true;
}

 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 #define WIN32_LEAN_AND_MEAN
 #include "windows.h"
 #endif
 
 #ifdef __cplusplus
 	extern "C" {
 #endif
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 		INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
 #else
 		int main(int argc, char *argv[])
 #endif
 		{
 			// Create application object
 			OBTutorial2 app;
 
 			try {
 				app.go();
 			} catch( Ogre::Exception& e ) {
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 				MessageBoxA( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
 #else
 				std::cerr << "An exception has occured: " <<
 					e.getFullDescription().c_str() << std::endl;
 #endif
 			}
 
 			return 0;
 		}
 
 #ifdef __cplusplus
 	}
 #endif